const axios = require('axios');

let Service, Characteristic, PlatformAccessory;

// ==================================================================================
//  MAIN PLUGIN EXPORT
// ==================================================================================

module.exports = (homebridge) => {
  console.log('[Growatt] Carregando plugin...');
  
  Service = homebridge.hap.Service;
  Characteristic = homebridge.hap.Characteristic;
  PlatformAccessory = homebridge.platformAccessory;

  homebridge.registerPlatform('homebridge-growatt-inversor', 'GrowattInversor', GrowattPlatform, false);
  console.log('[Growatt] Plugin registrado!');
};

// ==================================================================================
//  PLATFORM CLASS
// ==================================================================================

class GrowattPlatform {
  constructor(log, config, api) {
    this.log = log;
    this.config = config || {};
    this.api = api;
    this.accessories = new Map();
    this.plantIds = []; // Cache dos Plant IDs descobertos
    
    this.token = this.config.token;
    this.refreshInterval = (this.config.refreshInterval || 5) * 60 * 1000;

    this.log.info('*** GROWATT PLATFORM INICIANDO ***');
    
    if (!this.token) {
      this.log.error('‚ùå Token n√£o configurado na plataforma!');
      return;
    }

    this.log.info(`üîë Token: ${this.token.substring(0, 10)}...`);

    // Aguarda carregar completamente
    if (this.api) {
      this.api.on('didFinishLaunching', () => {
        this.log.info('üöÄ Homebridge carregado - iniciando descoberta inicial...');
        this.initialDiscovery();
      });
    }
  }

  // N√£o usar cache - ignorar qualquer acess√≥rio existente
  configureAccessory(accessory) {
    this.log.info(`üìÑ Ignorando acess√≥rio do cache: ${accessory.displayName || 'desconhecido'}`);
  }

  // Descoberta inicial - executa s√≥ UMA VEZ na inicializa√ß√£o
  async initialDiscovery() {
    this.log.info('üîç DESCOBERTA INICIAL - Buscando Plant IDs (s√≥ executa na inicializa√ß√£o)...');

    try {
      // Chamada √öNICA para descobrir os Plant IDs
      const response = await axios.get('https://openapi.growatt.com/v1/plant/list', {
        headers: { 'token': this.token },
        timeout: 15000
      });

      if (response.data.error_code !== 0) {
        throw new Error(`API Error: ${response.data.error_msg || 'Erro desconhecido'}`);
      }

      const plants = response.data.data?.plants || [];
      
      if (plants.length === 0) {
        this.log.warn('‚ö†Ô∏è Nenhum inversor encontrado na conta!');
        return;
      }

      this.log.info(`üì° Descobertos ${plants.length} inversor(es)`);

      // Salvar Plant IDs em cache
      this.plantIds = plants.map(plant => ({
        plantId: plant.plant_id,
        plantName: plant.name || `Inversor ${plant.plant_id}`,
        city: plant.city || 'N√£o informado',
        peakPower: plant.peak_power || 0,
        totalEnergy: parseFloat(plant.total_energy) || 0
      }));

      // Configurar acess√≥rios para cada Plant ID
      for (const plantInfo of this.plantIds) {
        this.log.info(`‚ûï Configurando: ${plantInfo.plantName} (Plant ID: ${plantInfo.plantId})`);
        
        const accessory = new PlatformAccessory(plantInfo.plantName, plantInfo.plantId.toString());
        
        accessory.context = {
          plantId: plantInfo.plantId,
          plantName: plantInfo.plantName,
          city: plantInfo.city,
          peakPower: plantInfo.peakPower,
          isProducing: false,
          currentPower: 0,
          todayEnergy: 0,
          totalEnergy: plantInfo.totalEnergy
        };

        this.configureAccessoryServices(accessory);
        this.accessories.set(plantInfo.plantId.toString(), accessory);
        this.api.registerPlatformAccessories('homebridge-growatt-inversor', 'GrowattInversor', [accessory]);
        
        this.log.info(`üîß ${plantInfo.plantName} configurado | Plant ID: ${plantInfo.plantId} | Peak: ${plantInfo.peakPower}W`);
      }

      this.log.info(`‚úÖ DESCOBERTA INICIAL FINALIZADA: ${this.plantIds.length} inversor(es) configurado(s)`);
      this.log.info('üîÑ Iniciando monitoramento cont√≠nuo...');

      // Iniciar monitoramento peri√≥dico de TODOS os inversores
      this.startPeriodicMonitoring();

    } catch (error) {
      this.log.error('‚ùå ERRO na descoberta inicial:');
      this.log.error(`Mensagem: ${error.message}`);
      
      if (error.response) {
        this.log.error(`Status HTTP: ${error.response.status}`);
        if (error.response.data) {
          this.log.error(`Resposta da API: ${JSON.stringify(error.response.data)}`);
        }
      }

      // Tentar novamente em 5 minutos se falhar
      this.log.warn('‚è≥ Tentando descoberta novamente em 5 minutos...');
      setTimeout(() => this.initialDiscovery(), 5 * 60 * 1000);
    }
  }

  // Monitoramento peri√≥dico - usa os Plant IDs em cache
  startPeriodicMonitoring() {
    this.log.info(`‚è∞ Iniciando monitoramento cont√≠nuo de ${this.plantIds.length} inversor(es)`);
    this.log.info(`üîÑ Intervalo: ${this.refreshInterval / 1000 / 60} minutos`);

    const updateAllData = async () => {
      this.log.info('üìä Atualizando dados de todos os inversores...');

      for (const plantInfo of this.plantIds) {
        const plantId = plantInfo.plantId;
        const plantName = plantInfo.plantName;
        const accessory = this.accessories.get(plantId.toString());

        if (!accessory) {
          this.log.warn(`‚ö†Ô∏è Acess√≥rio n√£o encontrado para Plant ID: ${plantId}`);
          continue;
        }

        try {
          // Buscar dados espec√≠ficos usando Plant ID em cache
          const response = await axios.get(`https://openapi.growatt.com/v1/plant/data?plant_id=${plantId}`, {
            headers: { 'token': this.token },
            timeout: 10000
          });

          if (response.data.error_code === 0 && response.data.data) {
            const data = response.data.data;
            
            const currentPower = parseFloat(data.current_power) || 0;
            const todayEnergy = parseFloat(data.today_energy) || 0;
            const totalEnergy = parseFloat(data.total_energy) || 0;
            const isProducing = currentPower > 0.1;

            // Atualizar contexto
            accessory.context.currentPower = currentPower;
            accessory.context.todayEnergy = todayEnergy;
            accessory.context.totalEnergy = totalEnergy;
            accessory.context.isProducing = isProducing;
            accessory.context.lastUpdate = new Date().toISOString();

            // Atualizar servi√ßos HomeKit
            this.updateAccessoryServices(accessory);

            const status = isProducing ? 'üü¢ PRODUZINDO' : 'üî¥ OFFLINE';
            this.log.info(`‚ö° ${plantName}: ${currentPower.toFixed(1)}W | Hoje: ${todayEnergy.toFixed(2)}kWh | Total: ${totalEnergy.toFixed(2)}kWh | ${status}`);
            
          } else {
            this.log.warn(`‚ö†Ô∏è ${plantName}: Dados inv√°lidos da API`);
            this.handleOfflineStatus(accessory);
          }

        } catch (error) {
          if (error.message.includes('frequently_access')) {
            this.log.warn(`‚è≥ ${plantName}: Rate limit - aguardando pr√≥ximo ciclo`);
          } else {
            this.log.error(`‚ùå ${plantName}: Erro no monitoramento - ${error.message}`);
          }
          this.handleOfflineStatus(accessory);
        }

        // Pequena pausa entre as chamadas para evitar sobrecarga
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    };

    // Primeira atualiza√ß√£o em 10 segundos
    setTimeout(updateAllData, 10000);
    
    // Monitoramento peri√≥dico a cada intervalo configurado
    this.monitoringTimer = setInterval(updateAllData, this.refreshInterval);
    
    this.log.info(`‚úÖ Monitoramento cont√≠nuo iniciado para ${this.plantIds.length} inversor(es)`);
  }

  // Atualizar servi√ßos do acess√≥rio com novos dados
  updateAccessoryServices(accessory) {
    const energyService = accessory.getService('Produ√ß√£o Solar');
    if (energyService) {
      energyService.updateCharacteristic(Characteristic.On, accessory.context.isProducing);
      energyService.updateCharacteristic(Characteristic.TotalConsumption, accessory.context.todayEnergy * 1000);
      energyService.updateCharacteristic(Characteristic.CurrentPowerConsumption, accessory.context.currentPower);
      energyService.updateCharacteristic(Characteristic.Voltage, 220);
    }

    const totalService = accessory.getService('Energia Total Hist√≥rica');
    if (totalService) {
      totalService.updateCharacteristic(Characteristic.CurrentAmbientLightLevel, accessory.context.totalEnergy);
    }
    
    const statusService = accessory.getService('Status Operacional');
    if (statusService) {
      statusService.updateCharacteristic(Characteristic.MotionDetected, accessory.context.isProducing);
    }
  }

  configureAccessoryServices(accessory) {
    const name = accessory.context.plantName;
    
    // Servi√ßo de informa√ß√£o
    let infoService = accessory.addService(Service.AccessoryInformation);
    infoService
      .setCharacteristic(Characteristic.Manufacturer, 'Growatt')
      .setCharacteristic(Characteristic.Model, 'Inversor Solar')
      .setCharacteristic(Characteristic.SerialNumber, accessory.context.plantId.toString())
      .setCharacteristic(Characteristic.FirmwareRevision, '1.2.0');

    // üîã MEDIDOR DE ENERGIA PRINCIPAL
    let energyService = accessory.addService(Service.Outlet, 'Produ√ß√£o Solar');
    energyService.setCharacteristic(Characteristic.Name, `${name} - Energia Hoje`);

    // Adicionar caracter√≠sticas de energia
    energyService.addCharacteristic(Characteristic.TotalConsumption);
    energyService.addCharacteristic(Characteristic.CurrentPowerConsumption);
    energyService.addCharacteristic(Characteristic.Voltage);

    // Status de produ√ß√£o (on/off)
    energyService
      .getCharacteristic(Characteristic.On)
      .onGet(() => {
        return accessory.context.isProducing || false;
      });

    // üìä SENSOR DE ENERGIA TOTAL HIST√ìRICA
    let totalService = accessory.addService(Service.LightSensor, 'Energia Total Hist√≥rica');
    totalService
      .setCharacteristic(Characteristic.Name, `${name} - Total Hist√≥rico`)
      .getCharacteristic(Characteristic.CurrentAmbientLightLevel)
      .setProps({ 
        minValue: 0, 
        maxValue: 999999,
        minStep: 0.01
      });

    // üü¢ SENSOR DE STATUS
    let statusService = accessory.addService(Service.MotionSensor, 'Status Operacional');
    statusService
      .setCharacteristic(Characteristic.Name, `${name} - Status`)
      .getCharacteristic(Characteristic.MotionDetected)
      .onGet(() => {
        return accessory.context.isProducing || false;
      });

    this.log.info(`üîß Servi√ßos configurados para: ${name}`);
  }

  // Tratar status offline
  handleOfflineStatus(accessory) {
    const name = accessory.context.plantName;
    
    const energyService = accessory.getService('Produ√ß√£o Solar');
    if (energyService) {
      energyService.updateCharacteristic(Characteristic.On, false);
      energyService.updateCharacteristic(Characteristic.CurrentPowerConsumption, 0);
    }

    const statusService = accessory.getService('Status Operacional');
    if (statusService) {
      statusService.updateCharacteristic(Characteristic.MotionDetected, false);
    }

    accessory.context.isProducing = false;
    accessory.context.currentPower = 0;
    
    this.log.warn(`üî¥ ${name}: OFFLINE`);
  }
}
